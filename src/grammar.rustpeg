use ast::{Expression, Value};

#[pub]
expressions -> Vec<Expression>
  = ws_delim_exprs

#[pub]
expression -> Expression
  = fn
  / call
  / assign
  / list
  / block
  / string_expr
  / bool
  / int
  / symbol

call -> Expression
  = i:identifier "(" __ e:comma_delim_exprs __ ")" { Expression::Call(i, e) }

assign -> Expression
  = i:identifier __ "=" __ e:expression { Expression::Assign(i, Box::new(e)) }

list -> Expression
  = "[" __ e:comma_delim_exprs __ "]" { Expression::List(e) }

string_expr -> Expression
  = "\"" s:string_with_ws "\"" { Expression::Value(Value::Str(s)) }

bool -> Expression
  = "true" { Expression::Value(Value::Bool(true)) }
  / "false" { Expression::Value(Value::Bool(false)) }

int -> Expression
  = d:digits { Expression::Value(Value::Int(d)) }

fn -> Expression
  = "fn" __ "(" __ a:comma_delim_idents __ ")" __ "{" __ e:ws_delim_exprs __ "}" {
    Expression::Value(Value::Fn(Box::new((a, e))))
  }

block -> Expression
  = "{" __ e:ws_delim_exprs __ "}" { Expression::Block(e) }

symbol -> Expression
  = i:identifier { Expression::Symbol(i) }

ws_delim_exprs -> Vec<Expression>
  = expression ++ __

comma_delim_exprs -> Vec<Expression>
  = expression ** comma_delim

comma_delim_idents -> Vec<String>
  = identifier ** comma_delim

digits -> i64
  = [0-9]+ { match_str.parse().unwrap() }

identifier -> String
  = [a-zA-Z] [a-zA-Z0-9_]* { match_str.to_owned() }

comma_delim = __ "," __

__ = [ \n]* comment* [ \n]*

comment = "#" comment_string_with_ws "\n"

comment_string_with_ws -> String
  = [a-zA-Z0-9\-><_ =(){}",]+ { match_str.to_owned() }

string_with_ws -> String
  = [a-zA-Z0-9_ ]+ { match_str.to_owned() }

string -> String
  = [a-zA-Z0-9_]+ { match_str.to_owned() }
